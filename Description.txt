可变参数在编译器中的处理:(转自：https://blog.csdn.net/lizhiqiang5846/article/details/37542323)

我们知道va_start,va_arg,va_end是在stdarg.h中被定义成宏的, 由于
(1)硬件平台的不同,
(2)编译器的不同,
所以定义的宏也有所不同,下面看一下VC++6.0中 stdarg.h 里的代码（文件的路径为VC安装目录下的\vc98\include\stdarg.h）

typedef char * va_list;
#define _INTSIZEOF(n) ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )
#define va_start(ap,v) ( ap = (va_list)&v + _INTSIZEOF(v) )
#define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ( ap = (va_list)0 )

下面解释这些代码的含义：
1、首先把va_list被定义成char*，这是因为在我们目前所用的PC机上，字符指针类型可以用来存储内存单元地址。而在有的机器上va_list是被定义成void*的

2、定义_INTSIZEOF(n)主要是为了某些需要内存的对齐的系统.这个宏的目的是为了得到最后一个固定参数的实际内存大小。(在我的机器上直接用sizeof运算符来代替，对程序的运行结构也没有影响。)

3、va_start的定义为&v+_INTSIZEOF(v),而&v是最后一个固定参数的起始地址，再加上其大小后，就得到了第一个可变参数的起始内存地址。所以我们运行va_start(ap, v)以后,ap指向第一个可变参数在的内存地址,有了这个地址，以后的事情就简单了。

这里要知道两个事情：
(1)在intel+windows的机器上，函数栈的方向是向下的，栈顶指针的内存地址低于栈底指针，所以先进栈的数据是存放在内存的高地址处。
(2)在VC等绝大多数C编译器中，参数进栈的顺序是由右向左的，因此，参数进栈以后的内存模型如下图所示：
（最后一个固定参数的地址正好位于第一个可变参数之下，并且是连续存储的。）

|—— —————————————|
| 最后一个固定参数 | ->高内存地址处
|— ——————————————|

........................
|-------------------------------|
| 第N个可变参数 | ->va_arg(arg_ptr,datatype)后arg_ptr所指的地方
|-------------------------------|

...................
|——— ————————————|
| 第一个可变参数 | ->va_start(arg_ptr,start)后arg_ptr所指的地方
| | 即第一个可变参数的地址
|——————————————— |
|————————————— ——|
| |
| 最后一个固定参数 | -> start的起始地址
|—————————————— —|
...............
|——————————————- |
| |
|——————————————— | -> 低内存地址处

4、va_arg():有了va_start的良好基础，我们取得了第一个可变参数的地址，在va_arg()里的任务就是根据指定的参数类型取得本参数的值，并且把指针调到下一个参数的起始地址。因此，现在再来看va_arg()的实现就应该心中有数了：
#define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
这个宏做了两个事情，
①用用户输入的类型对参数地址进行强制类型转换，得到用户所需要的值
②计算出本参数的实际大小，将指针调到本参数的结尾，也就是下一个参数的首地址，以便后续处理。

5、va_end宏的解释：x86平台定义为ap=(char*)0;使ap不再 指向堆栈,而是跟NULL一样.有些直接定义为((void*)0),这样编译器不会为va_end产生代码,
例如gcc在linux的x86平台就是这样定义的. 在这里大家要注意一个问题:由于参数的地址用于va_start宏,所 以参数不能声明为寄存器变量或作为函数或数组类型.
关于va_start, va_arg, va_end的描述就是这些了,我们要注意的 是不同的操作系统和硬件平台的定义有些不同,但原理却是相似的.